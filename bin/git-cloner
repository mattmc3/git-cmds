#!/usr/bin/env bash

##? cloner: A better git cloner.
#
# Usage:
#   git cloner [--profile=<name>] [-d|--debug] [<git-clone-flags>] <repo> [<dest>]
#
# Features:
#   - Support short user/repo form
#   - Default clone to ~/repos (configurable), not $PWD unless dir arg provided
#   - Profile support for multiple git identities (work, personal, etc.)
#   - SSH key and template support via git config
#
# Git config:
#   [cloner]
#       repoRoot = ~/repos
#       gitOwner = myuser
#       gitDomain = github.com
#       gitProtocol = https
#       cloneAddFlags = --recurse-submodules
#       sshKey = ~/.ssh/id_ed25519
#       template = ~/.config/git/templates/default
#
#   # Profile overrides (git cloner --profile=work)
#   [cloner "work"]
#       gitOwner = workorg
#       ownerAlias = work
#       gitProtocol = ssh
#       sshKey = ~/.ssh/github_work
#       template = ~/.config/git/templates/work

VERSION="1.0.1"

say() { printf '%s\n' "$@"; }
warn() { say "$@" >&2; }
die() { warn "$@"; exit "${ERR:-1}"; }

# Profile-aware git config lookup.
# Falls back from cloner.<profile>.<key> to cloner.<key>.
cfg() {
  if [[ -n "$profile" ]]; then
    git config "cloner.${profile}.${1}" 2>/dev/null || git config "cloner.${1}" 2>/dev/null
  else
    git config "cloner.${1}" 2>/dev/null
  fi
}

# Take a repo and make it into the short user/repo form.
to_short_repo() {
  [[ $# -eq 1 ]] || return 1
  local default_user
  default_user="$(cfg gitOwner || git config user.name || whoami)"
  # Prepend default git user to always make 2+ fields and print user/repo form
  say "${default_user}/${1}" | awk -F '[/:]' '{ print $(NF-1) "/" $NF }'
}

# Take a repo and determine its clone destination.
# Path is always: repoRoot / owner / repo
# ownerAlias overrides the owner directory name when it matches gitOwner.
to_repo_dir() {
  [[ $# -eq 1 ]] || return 1
  local dir short_repo owner repo_name alias git_owner
  short_repo="$(to_short_repo "$1")"
  owner="${short_repo%/*}"
  repo_name="${short_repo##*/}"
  dir="$(cfg repoRoot || say "$HOME/repos")"
  dir="${dir/#\~/$HOME}"
  alias="$(cfg ownerAlias)"
  git_owner="$(cfg gitOwner)"
  if [[ -n "$alias" && "$owner" == "$git_owner" ]]; then
    owner="$alias"
  fi
  say "${dir}/${owner}/${repo_name}"
}

# Take a repo and determine its URL.
to_repo_url() {
  [[ $# -eq 1 ]] || return 1
  case $1 in https://*|git@*) say "$1"; return ;; esac

  local gitdomain gitprotocol repo
  gitdomain="$(cfg gitDomain || say 'github.com')"
  gitprotocol="$(cfg gitProtocol || say 'https')"
  repo="$(to_short_repo "$1")"

  case $gitprotocol in
    ssh|git)
      say "git@${gitdomain}:${repo}.git"
      ;;
    *)
      say "${gitprotocol}://${gitdomain}/${repo}"
      ;;
  esac
}

cloner() {
  local profile dir repo repo_arg debug=false
  local ssh_key template

  # Parse cloner flags.
  local -a args=()
  while [[ $# -gt 0 ]]; do
    case $1 in
      --profile=*) profile="${1#--profile=}" ;;
      --profile)   profile="$2"; shift ;;
      -d|--debug)  debug=true ;;
      -v|--version) say "git-cloner $VERSION"; return ;;
      *)           args+=("$1") ;;
    esac
    shift
  done
  set -- "${args[@]}"

  if [[ $# -eq 0 ]]; then
    die "clone: Expecting a repo argument. See 'git clone -h'."
  fi

  # If multiple args and the last looks like a path (~ / . $), treat it as the
  # clone destination directory.
  if [[ $# -gt 1 && "${*: -1}" == [./~\$]* ]]; then
    dir="${*: -1}"
    set -- "${@:1:$#-1}"
  fi

  # Last arg is the repo; everything before it is pass-through flags.
  repo_arg="${*: -1}"
  set -- "${@:1:$#-1}"

  [[ -z "$dir" ]] && dir="$(to_repo_dir "$repo_arg")"
  repo="$(to_repo_url "$repo_arg")"

  # Already cloned? Output dir and exit 150.
  if [[ -d "$dir" ]]; then
    say "$dir"
    exit 150
  fi

  # Read profile config.
  ssh_key="$(cfg sshKey)";       ssh_key="${ssh_key/#\~/$HOME}"
  template="$(cfg template)";    template="${template/#\~/$HOME}"


  # Build clone command.
  local -a clone_cmd=(command git clone)
  local -a addflags
  read -ra addflags <<< "$(cfg cloneAddFlags)"
  [[ ${#addflags[@]} -gt 0 ]] && clone_cmd+=("${addflags[@]}")
  [[ -n "$template" ]] && clone_cmd+=("--template=$template")
  clone_cmd+=("$@" "$repo" "$dir")

  # Clone, with SSH key if configured.
  if [[ -n "$ssh_key" ]]; then
    local ssh_cmd="ssh -i $ssh_key -o IdentitiesOnly=yes"
    if [[ "$debug" == true ]]; then
      warn "GIT_SSH_COMMAND=\"$ssh_cmd\" ${clone_cmd[*]}"
    fi
    GIT_SSH_COMMAND="$ssh_cmd" "${clone_cmd[@]}"
  else
    if [[ "$debug" == true ]]; then
      warn "${clone_cmd[*]}"
    fi
    "${clone_cmd[@]}"
  fi

  # Post-clone setup.
  if [[ -d "$dir" ]]; then
    [[ -n "$ssh_key" ]] && git -C "$dir" config core.sshCommand "ssh -i $ssh_key"
    say "$dir"
  fi
}
cloner "$@"
